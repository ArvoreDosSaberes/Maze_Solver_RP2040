<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RP2040 Maze Solver: RP2040 Maze Solver – Plano e Requisitos</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">RP2040 Maze Solver<span id="projectnumber">&#160;0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_PLAN.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">RP2040 Maze Solver – Plano e Requisitos</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md16"></a> Documento vivo para guiar o desenvolvimento do firmware, testes e simulador do carrinho solucionador de labirintos.</p>
<h1><a class="anchor" id="autotoc_md17"></a>
Objetivo</h1>
<p>Construir um sistema embarcado (RP2040) que:</p><ul>
<li>Encontre saída de labirintos, começando com estratégia “Mão Direita”.</li>
<li>Construa um mapa e, após explorar, use rota ótima (flood fill/A*).</li>
<li>Aprenda/ajuste heurísticas ao longo de execuções e persista resultados.</li>
<li>Ofereça testes unitários (Unity) e simulador gráfico (SDL2) no host.</li>
</ul>
<h1><a class="anchor" id="autotoc_md18"></a>
Requisitos Funcionais</h1>
<ul>
<li>[x] Estratégia inicial Right-hand como fallback.</li>
<li>[x] Construção de mapa do labirinto durante exploração.</li>
<li>[x] Planejamento de rota ótima (flood fill/A*).</li>
<li>[x] Persistência de heurísticas e mapas:<ul>
<li>[x] RP2040: heurísticas em flash (hardware_flash) com cabeçalho de integridade.</li>
<li>[x] Host: arquivos (ex.: ~/.rp2040_maze/).</li>
<li>[x] Snapshot de mapa (RP2040/host).</li>
</ul>
</li>
<li>[x] Componente de aprendizado simples (pesos/heurísticas) aplicado às decisões.</li>
<li>[x] Reutilizar conhecimento entre execuções e demonstrar melhora ou estabilidade.</li>
<li>[x] Simulador gráfico com paredes verdes e carrinho vermelho.</li>
<li>[x] Testes com 4 labirintos aleatórios; repetir 2 e verificar melhoria/igual.<ul>
<li>[x] Simulador: salvar/carregar labirintos em JSON e seleção de labirinto via menu.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md19"></a>
Requisitos Não Funcionais</h1>
<ul>
<li>Código organizado por camadas: core, hal, firmware, simulator, tests.</li>
<li>Build configurável via CMake (firmware/testes/simulador opcionais).</li>
<li>Fail-safes mínimos no controle (validação sensores, clamps, stop em obstáculo).</li>
<li>Configuração por macros CMake para pinos/canais e parâmetros.</li>
</ul>
<h1><a class="anchor" id="autotoc_md20"></a>
Arquitetura / Pastas</h1>
<ul>
<li><code>firmware/</code>: entrada RP2040 (<code>main.cpp</code>) e loop de controle.</li>
<li><code>src/core/</code>: lógica de navegação e suporte (Navigator, MazeMap, Planner, Learning, PersistentMemory).</li>
<li><code>src/hal/</code>: abstrações de hardware (motores via ponte H, sensores IR ADC).</li>
<li><code>simulator/</code>: simulador host (SDL2) para visualização e métricas.</li>
<li><code>tests/</code>: testes Unity.</li>
<li><code>inc/Unity/</code>: framework de testes Unity (vendorizado).</li>
</ul>
<h1><a class="anchor" id="autotoc_md21"></a>
Itens Implementados</h1>
<h2><a class="anchor" id="autotoc_md22"></a>
Versão 0.0.1</h2>
<ul>
<li>[x] <code>Navigator</code> com estratégia Right-hand, integração com <code>MazeMap</code>/<code>Planner</code> (BFS) e pontuação com <code>Heuristics</code>.</li>
<li>[x] HAL de motores (ponte H) e sensores IR (ADC + EMA).</li>
<li>[x] Fail-safes no controle (firmware <code>main.cpp</code>).</li>
<li>[x] CMake com opções: <code>BUILD_FIRMWARE</code> (ON), <code>BUILD_TESTS</code> (OFF), <code>BUILD_SIM</code> (OFF).</li>
<li>[x] Teste Unity básico para Right-hand.</li>
<li>[x] <code>PersistentMemory</code> stubs (status/erase) + API heurísticas (save/load) stub in-memory.</li>
<li>[x] Esqueleto de simulador SDL2 (só janela/desenhos básicos).</li>
<li>[x] <code><a class="el" href="MazeMap_8hpp.html" title="Estruturas e classe para representação de um labirinto em grade.">MazeMap.hpp</a></code>: grid e paredes bidirecionais com <code>set_wall()</code>.</li>
<li>[x] <code><a class="el" href="Planner_8hpp.html" title="Planejador de caminho em grade usando BFS sobre MazeMap.">Planner.hpp</a></code>: BFS/flood fill inicial com <code>Planner::bfs_path()</code>.</li>
<li>[x] Testes do planner (<code>tests/test_planner.cpp</code>) e separação de executáveis de teste no CMake (<code>maze_tests</code> e <code>planner_tests</code>) para evitar múltiplos <code><a class="el" href="firmware_2main_8cpp.html#ae66f6b31b5ad750f1fe042a706a4e3d4" title="Ponto de entrada do firmware.">main()</a></code>).</li>
<li>[x] Firmware: integração completa do <code>Navigator</code> (observeCellWalls/planRoute/decidePlanned), reforço com <code>applyReward()</code> e persistência de heurísticas no goal.</li>
<li>[x] Doxygen básico configurado (OUTPUT para <code>docs/</code>, alvo CMake <code>docs</code>).</li>
<li>[x] Unity excluído da indexação do Doxygen (<code>EXCLUDE = inc/Unity</code>).</li>
<li>[x] Licença definida para CC BY-SA 4.0 e arquivo <code>LICENSE</code> adicionado.</li>
<li>[x] Simulador: helpers para serializar/deserializar labirinto em JSON (dimensões, paredes, entrada, objetivo e metadados) e utilitários de filesystem (<code>maze/</code>).<ul>
<li>[x] Simulador: coleta de metadados via variáveis de ambiente (<code>GIT_AUTHOR_NAME</code>, <code>GIT_AUTHOR_EMAIL</code>, <code>GITHUB_PROFILE</code>) ou entrada interativa ao salvar JSON.</li>
<li>[x] Simulador: menu simples para escolher labirinto JSON existente em <code>maze/</code> ou gerar aleatório e salvar.</li>
</ul>
</li>
<li>[x] CI/CD: Adicionar workflow de CI (GitHub Actions) para compilar testes e rodar CTest.</li>
<li>[x] GIT: Adicionar os arquivos por grupos de funcionalidade e criar os comiits documentando.</li>
<li>[x] GIT: Ajustar o <a class="el" href="PLAN_8md.html">PLAN.md</a> E <a class="el" href="README_8md.html">README.md</a> para refletir as alterações de versão.<ul>
<li>fazer o merge para o main</li>
<li>fazer o push para o repositório. </li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md23"></a>
Próximos passos versão 0.0.3</h2>
<ul>
<li>[x] Adicionar frame lateral com informações do carrinho e suas decisões como é feito no terminal</li>
<li>[x] Adicionar um novo botão para iniciar a solução do labirinto, outro para gerar um novo labirinto aleatório e salvar.<ul>
<li>Observação: requer <code>SDL2_ttf</code> para exibir textos/labels; sem ele, o simulador funciona, porém sem rótulos.</li>
<li>Modal de metadados (uma vez por sessão) quando <code>SDL2_ttf</code> está presente; caso contrário, usa variáveis de ambiente (<code>GIT_AUTHOR_NAME</code>, <code>GIT_AUTHOR_EMAIL</code>, <code>GITHUB_PROFILE</code>).</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md24"></a>
Próximos passos versão 0.0.4</h1>
<ul>
<li>[ ] Carrinho deve demonstrar o planejamento em tempo real</li>
</ul>
<h1><a class="anchor" id="autotoc_md25"></a>
Próximos passos (curto prazo)</h1>
<p>Consolidado em "Itens Implementados – Versão 0.0.1". Planejamento em andamento na seção de v0.0.2. </p>
<h1><a class="anchor" id="autotoc_md26"></a>
Build Targets e Opções (CMake)</h1>
<ul>
<li>Opções:<ul>
<li><code>-DBUILD_FIRMWARE=ON|OFF</code></li>
<li><code>-DBUILD_TESTS=ON|OFF</code></li>
<li><code>-DBUILD_SIM=ON|OFF</code></li>
</ul>
</li>
<li>Firmware RP2040: Pico SDK apenas quando <code>BUILD_FIRMWARE=ON</code>.</li>
<li>Testes/Simulador (host): toolchain nativa; Unity/SDL2 opcionais.</li>
</ul>
<p>Exemplos de uso: </p><div class="fragment"><div class="line"># Testes (host)</div>
<div class="line">cmake -B build-test -S . -DBUILD_TESTS=ON -DBUILD_FIRMWARE=OFF -DBUILD_SIM=OFF</div>
<div class="line">cmake --build build-test -j</div>
<div class="line">ctest --test-dir build-test -V</div>
<div class="line"> </div>
<div class="line"># Simulador</div>
<div class="line">cmake -B build-sim -S . -DBUILD_SIM=ON -DBUILD_TESTS=OFF -DBUILD_FIRMWARE=OFF</div>
<div class="line">cmake --build build-sim -j</div>
<div class="line"> </div>
<div class="line"># Firmware (RP2040)</div>
<div class="line">cmake -B build -S . -DBUILD_FIRMWARE=ON -DBUILD_TESTS=OFF -DBUILD_SIM=OFF</div>
<div class="line">cmake --build build -j</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md27"></a>
Observações do simulador (SDL2 e JSON)</h2>
<ul>
<li>SDL2 é necessário no host para compilar o alvo <code>simulator</code>. Em distribuições Debian/Ubuntu, instale com: <code>sudo apt-get install libsdl2-dev</code>.</li>
<li>O simulador cria/usa as pastas <code>maze/</code> (arquivos <code>.json</code>) e <code>make/</code> automaticamente, quando necessário.</li>
<li>Menu do simulador:<ul>
<li>Lista arquivos <code>maze/*.json</code> em ordem alfabética para seleção.</li>
<li>Opção de gerar um labirinto aleatório e salvar como JSON com metadados.</li>
</ul>
</li>
<li>Metadados no JSON: <code>creator_name</code>, <code>creator_email</code>, <code>github_profile</code>, <code>timestamp</code>.<ul>
<li>Podem ser preenchidos via variáveis de ambiente: <code>GIT_AUTHOR_NAME</code>, <code>GIT_AUTHOR_EMAIL</code>, <code>GITHUB_PROFILE</code>.</li>
<li>Se ausentes, o simulador solicita entrada interativa.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md28"></a>
Configuração por Macros (exemplos)</h1>
<ul>
<li>Motores: <code>CFG_MOTOR_*</code> (pinos, pwm, inversões, etc.).</li>
<li>Sensores IR: <code>CFG_IR_ADC_*</code> (canais ADC e parâmetros de filtro).</li>
<li>Velocidades/limiares: <code>CFG_TARGET_SPEED_CM_S</code>, etc.</li>
</ul>
<h1><a class="anchor" id="autotoc_md29"></a>
Métricas de Sucesso</h1>
<ul>
<li>Encontra saída com Right-hand em labirintos simples.</li>
<li>Após explorar, gera rota ótima e a segue corretamente.</li>
<li>Persistência funcionando: carrega heurísticas/mapa e melhora/estabiliza desempenho.</li>
<li>Testes Unity passam em host e simulador exibe trajetórias corretas.</li>
</ul>
<h1><a class="anchor" id="autotoc_md30"></a>
Notas de Manutenção</h1>
<ul>
<li>Este arquivo deve ser atualizado a cada entrega concluída (marcar checkboxes) e quando escopo/decisões mudarem.</li>
</ul>
<p>Desenvolva um firmware para um carrinho que soluciona labirintos, ele deve buscar a melhor saida do labiringo, armazenando em sua memória os labrintos solucionados de forma que possa reutilizar em novas tentativas de solução, inicialmente ele deve usar o algorimo da mão direita onde ele sempre tentará primeiro a opção de saida a direita, em seguida ele deve ir melhorando as táticas com novos algorítimos de solução, crie classes que abstraia o acesso as portas PWM para controle dos motores, o carrinho tem dois motores para controlar as rodas de forma a definir a direção, crie uma classe que abstraia o acesso aos sensores de obstáculos analógicos ifravermelhos reflexivos para identificar as opções de saida, a esquerda, frente e direita, faça testes unitários que abra uma interface gráfica que representa o labirinto a ser solucionado de forma aleatóiria teste 4 labirintos aleatóris e repita dois para constatar o melhoramento do algortimo genético. a interface gráfica deve representar o labirinto com suas paredes em verde e o carrinho como um circuito vermelho. use o framework unity que está na biblioteca /inc/unity. apresente o plano para eu aprovar ou fazer alterçaões. faça os ajustes necessários no CMakeFiles.txt para adicionar as bibliotecas e as dependências necessárias para o unity.</p>
<h1><a class="anchor" id="autotoc_md31"></a>
Estado atual da documentação (Doxygen)</h1>
<ul>
<li>[x] <code><a class="el" href="MazeMap_8hpp.html" title="Estruturas e classe para representação de um labirinto em grade.">src/core/MazeMap.hpp</a></code></li>
<li>[x] <code><a class="el" href="Learning_8hpp.html" title="Estruturas e utilitários de heurística/aprendizado simples.">src/core/Learning.hpp</a></code></li>
<li>[x] <code><a class="el" href="Navigator_8hpp.html" title="Núcleo de decisão de navegação (plataforma-agnóstico).">src/core/Navigator.hpp</a></code></li>
<li>[x] <code><a class="el" href="PersistentMemory_8hpp.html" title="API de persistência de labirintos e estatísticas.">src/core/PersistentMemory.hpp</a></code></li>
<li>[x] <code><a class="el" href="IRSensorArray_8hpp.html" title="Leitura de 3 sensores IR reflexivos analógicos via ADC.">src/hal/IRSensorArray.hpp</a></code></li>
<li>[x] <code><a class="el" href="Planner_8hpp.html" title="Planejador de caminho em grade usando BFS sobre MazeMap.">src/core/Planner.hpp</a></code></li>
<li>[x] <code><a class="el" href="PersistentMemory_8cpp.html" title="Implementação da persistência em flash (RP2040) e em arquivo (host).">src/core/PersistentMemory.cpp</a></code> (constantes, macros, helpers e métodos)</li>
<li>[x] <code><a class="el" href="Navigator_8cpp.html">src/core/Navigator.cpp</a></code> (métodos e helpers)</li>
<li>[x] <code><a class="el" href="IRSensorArray_8cpp.html" title="Implementação da leitura e filtragem dos sensores IR via ADC.">src/hal/IRSensorArray.cpp</a></code> (construtor, helper ADC, <code>readAll()</code>)</li>
<li>[x] <code><a class="el" href="MotorControl_8hpp.html" title="Interface do controle de dois motores (esquerdo/direito) com mapeamento de velocidades normalizadas e...">src/hal/MotorControl.hpp</a></code></li>
<li>[x] Implementações <code>src/hal/h_bridge/*</code></li>
<li>[x] <code><a class="el" href="firmware_2main_8cpp.html" title="Firmware principal do carrinho resolvedor de labirintos (RP2040).">firmware/main.cpp</a></code> macros <code>CFG_*</code>, callback e fluxo (feito)</li>
<li>[x] <code>simulator/</code> e <code>tests/</code> (descrições e uso) (feito)</li>
</ul>
<ol type="1">
<li>Fase 3 – Firmware<ul>
<li>Concluída. <code><a class="el" href="firmware_2main_8cpp.html" title="Firmware principal do carrinho resolvedor de labirintos (RP2040).">firmware/main.cpp</a></code> documentado (macros <code>CFG_*</code>, callbacks/loop, comandos, integração <code>Navigator</code>/<code>PersistentMemory</code>).</li>
</ul>
</li>
<li>Fase 4 – Simulador e Testes<ul>
<li>Concluída. Simulador e testes documentados (execução, dependências, propósito por arquivo).</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md32"></a>
Convenções Doxygen</h2>
<ul>
<li>Cabeçalho por arquivo: <code>@file</code>, <code>@brief</code>, detalhes, autor, <code>@since</code>.</li>
<li>Em classes/métodos: <code>@brief</code>, <code>@param</code>, <code>@return</code>, <code>@throws</code> (se aplicável), exemplos curtos.</li>
<li>Para macros/constantes públicas: explicar unidade, faixa, efeito no sistema.</li>
<li>Preferir <code>@copydoc</code> em .cpp quando a assinatura está no .hpp.</li>
<li>Manter nomes totalmente qualificados (ex.: <code><a class="el" href="classmaze_1_1Navigator.html" title="Estratégias de navegação disponíveis.">maze::Navigator</a></code>).</li>
</ul>
<h2><a class="anchor" id="autotoc_md33"></a>
Definition of Done (DoD)</h2>
<ul>
<li>Build <code>docs</code> sem erros e sem avisos novos.</li>
<li>Cobertura: símbolos públicos documentados nas pastas alvo; itens internos podem ser resumidos.</li>
<li>README, PLAN e REFERENCE atualizados quando necessário.</li>
</ul>
<h2><a class="anchor" id="autotoc_md34"></a>
Próximas ações</h2>
<ul>
<li>Geração de release v0.0.2 com integração JSON do simulador e correções de build (includes e organização de código em <code><a class="el" href="simulator_2main_8cpp.html" title="Simulador SDL2 do resolvedor de labirintos (visualização 2D).">simulator/main.cpp</a></code>).</li>
<li>Atualizar README/CHANGELOG com instruções e notas de versão.</li>
<li>(Opcional) Publicar <code>docs/</code> via GitHub Pages e manter artifact de Doxygen no CI. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
